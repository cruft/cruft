{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trending Contributors Read Latest Documentation - Browse GitHub Code Repository cruft allows you to maintain all the necessary boilerplate for packaging and building projects separate from the code you intentionally write. Fully compatible with existing Cookiecutter templates. Creating new projects from templates using cruft is easy: And, so is updating them as the template changes overtime: Many project template utilities exist that automate the copying and pasting of code to create new projects. This seems great! However, once created, most leave you with that copy-and-pasted code to manage through the life of your project. cruft is different. It automates the creation of new projects like the others, but then it also helps you to manage the boilerplate through the life of the project. cruft makes sure your code stays in-sync with the template it came from for you. Key Features Cookiecutter Compatible : cruft utilizes Cookiecutter as its template expansion engine. Meaning it retains full compatibility with all existing Cookiecutter templates. Template Validation : cruft can quickly validate whether or not a project is using the latest version of a template using cruft check . This check can easily be added to CI pipelines to ensure your projects stay in-sync. Automatic Template Updates : cruft automates the process of updating code to match the latest version of a template, making it easy to utilize template improvements across many projects. Installation To get started - install cruft using a Python package manager: pip3 install cruft OR poetry add cruft OR pipenv install cruft Creating a New Project To create a new project using cruft run cruft create PROJECT_URL from the command line. For example: cruft create https://github.com/timothycrosley/cookiecutter-python/ cruft will then ask you any necessary questions to create your new project. It will use your answers to expand the provided template, and then return the directory it placed the expanded project. Behind the scenes, cruft uses Cookiecutter to do the project expansion. The only difference in the resulting output is a .cruft.json file that contains the git hash of the template used as well as the template variables specified. Updating a Project To update an existing project, that was created using cruft, run cruft update in the root of the project. If there are any updates, cruft will have you review them before applying. If you accept the changes cruft will apply them to your project and update the .cruft.json file for you. Tip Sometimes certain files just aren't good fits for updating. Such as test cases or __init__ files. You can tell cruft to always skip updating these files on a project by generating project with --skip cruft/__init__.py --skip tests arguments or manually adding them to a skip section within your .cruft.json file: { \"template\": \"https://github.com/timothycrosley/cookiecutter-python\", \"commit\": \"8a65a360d51250221193ed0ec5ed292e72b32b0b\", \"skip\": [ \"cruft/__init__.py\", \"tests\" ], ... } Or, if you have toml installed, you can add skip files directly to a tool.cruft section of your pyproject.toml file: [tool.cruft] skip = [\"cruft/__init__.py\", \"tests\"] Note that it is possible to use glob patterns for selecting the files to skip: { \"skip\": [ \"* / init .py\", \"tests/ \" ], ... } Updating Values of Template Variables cruft can also be used to update a project to use new values of template variables; avoiding the need to regenerate the project from sratch using cookiecutter . For example, imagine a project that was initially generated some while ago, and then later on, you want to change the values of some of the template variables, e.g. to change use_some_feature to \"yes\" or to change project_name to \"new-project-name\" . There are 2 ways this can be done, as described below. Update Variables via the Command Line You can perform the update directly via the command line if you have only a handful of simple variables. This will change use_some_feature to \"yes\" while leaving all other variables unchanged: cruft update --variables-to-update '{ \"use_some_feature\" : \"yes\" }' This will change both use_some_feature to \"yes\" and project_name to \"new-project-name\" (and still leaving all other variables unchanged): cruft update --variables-to-update '{ \"use_some_feature\" : \"yes\", \"project_name\" : \"new-project-name\" }' The provided argument must be a valid JSON string (i.e. using double quotes, no trailing comma etc.). Update Variables via a Cruft File If you prefer to use and editor or you have many or complex variables, you can also perform the changes via providing an updated .cruft.json. # copy the existing cruft file to a temporary location (outside of your repo) cp .cruft.json ~/tmp/new-cruft.json # edit the file using your faviourite editor edit ~/tmp/new-cruft.json # perform the update # (this will also update your original .cruft.json automatically) cruft update --variables-to-update-file ~/tmp/new-cruft.json Checking a Project Checking to see if a project is missing a template update is as easy as running cruft check . If the project is out-of-date an error and exit code 1 will be returned. cruft check can be added to CI pipelines to ensure projects don't unintentionally drift. Linking an Existing Project Have an existing project that you created from a template in the past using Cookiecutter directly? You can link it to the template that was used to create it using: cruft link TEMPLATE_REPOSITORY . For example: cruft link https://github.com/timothycrosley/cookiecutter-python/ You can then specify the last commit of the template the project has been updated to be consistent with, or accept the default of using the latest commit from the template. Compute the diff With time, your boilerplate may end up being very different from the actual cookiecutter template. Cruft allows you to quickly see what changed in your local project compared to the template. It is as easy as running cruft diff . If any local file differs from the template, the diff will appear in your terminal in a similar fashion to git diff . The cruft diff command optionally accepts an --exit-code flag that will make cruft exit with a non-0 code should any diff is found. You can combine this flag with the skip section of your .cruft.json to make stricter CI checks that ensures any improvement to the template is always submitted upstream. Automating updates with GitHub Actions If you have many repositories to manage, you can automate the change detection process with GitHub Actions. This example runs every Monday at 2am UTC and creates a new pull request if there are changes detected which a maintainer can accept or reject. It creates two PRs - one to pull in the new files to the repository and one to update the .cruft.json file only, which has the effect of rejecting the change from the upstream repository. Since Jan 2022, registries/organisations must explicitly grant the authority to create a pull request. This can be enabled on a per-organisation level, or a per-registry level for personal projects. See GitHub for more details. # /.github/workflows/cruft-update.yml name : Update repository with Cruft permissions : contents : write pull-requests : write on : schedule : - cron : \"0 2 * * 1\" # Every Monday at 2am jobs : update : runs-on : ubuntu-latest strategy : fail-fast : true matrix : include : - add-paths : . body : Use this to merge the changes to this repository. branch : cruft/update commit-message : \"chore: accept new Cruft update\" title : New updates detected with Cruft - add-paths : .cruft.json body : Use this to reject the changes in this repository. branch : cruft/reject commit-message : \"chore: reject new Cruft update\" title : Reject new updates detected with Cruft steps : - uses : actions/checkout@v3 - uses : actions/setup-python@v4 with : python-version : \"3.10\" - name : Install Cruft run : pip3 install cruft - name : Check if update is available continue-on-error : false id : check run : | CHANGES=0 if [ -f .cruft.json ]; then if ! cruft check; then CHANGES=1 fi else echo \"No .cruft.json file\" fi echo \"has_changes=$CHANGES\" >> \"$GITHUB_OUTPUT\" - name : Run update if available if : steps.check.outputs.has_changes == '1' run : | git config --global user.email \"you@example.com\" git config --global user.name \"GitHub\" cruft update --skip-apply-ask --refresh-private-variables git restore --staged . - name : Create pull request if : steps.check.outputs.has_changes == '1' uses : peter-evans/create-pull-request@v4 with : token : ${{ secrets.GITHUB_TOKEN }} add-paths : ${{ matrix.add-paths }} commit-message : ${{ matrix.commit-message }} branch : ${{ matrix.branch }} delete-branch : true branch-suffix : timestamp title : ${{ matrix.title }} body : | This is an autogenerated PR. ${{ matrix.body }} [Cruft](https://cruft.github.io/cruft/) has detected updates from the Cookiecutter repository. Why Create cruft? Since I first saw videos of quickly being used to automate Ubuntu application creation, I've had a love/hate relationship with these kinds of tools. I've used them for many projects and certainly seen them lead to productivity improvements. However, I've always felt like they were a double-edged sword. Sure, they would automate away the copying and pasting many would do to create projects. However, by doing so, they encouraged more code to be copied and pasted! Then, over time, you could easily be left with hundreds of projects that contained copy-and-pasted code with no way to easy way to update them. I created cruft to be a tool that recognized that balance between project creation and maintenance and provided mechanisms to keep built projects up-to-date. I hope you too find cruft useful! ~Timothy Crosley","title":"Home"},{"location":"#trending-contributors","text":"Read Latest Documentation - Browse GitHub Code Repository cruft allows you to maintain all the necessary boilerplate for packaging and building projects separate from the code you intentionally write. Fully compatible with existing Cookiecutter templates. Creating new projects from templates using cruft is easy: And, so is updating them as the template changes overtime: Many project template utilities exist that automate the copying and pasting of code to create new projects. This seems great! However, once created, most leave you with that copy-and-pasted code to manage through the life of your project. cruft is different. It automates the creation of new projects like the others, but then it also helps you to manage the boilerplate through the life of the project. cruft makes sure your code stays in-sync with the template it came from for you.","title":"Trending Contributors"},{"location":"#key-features","text":"Cookiecutter Compatible : cruft utilizes Cookiecutter as its template expansion engine. Meaning it retains full compatibility with all existing Cookiecutter templates. Template Validation : cruft can quickly validate whether or not a project is using the latest version of a template using cruft check . This check can easily be added to CI pipelines to ensure your projects stay in-sync. Automatic Template Updates : cruft automates the process of updating code to match the latest version of a template, making it easy to utilize template improvements across many projects.","title":"Key Features"},{"location":"#installation","text":"To get started - install cruft using a Python package manager: pip3 install cruft OR poetry add cruft OR pipenv install cruft","title":"Installation"},{"location":"#creating-a-new-project","text":"To create a new project using cruft run cruft create PROJECT_URL from the command line. For example: cruft create https://github.com/timothycrosley/cookiecutter-python/ cruft will then ask you any necessary questions to create your new project. It will use your answers to expand the provided template, and then return the directory it placed the expanded project. Behind the scenes, cruft uses Cookiecutter to do the project expansion. The only difference in the resulting output is a .cruft.json file that contains the git hash of the template used as well as the template variables specified.","title":"Creating a New Project"},{"location":"#updating-a-project","text":"To update an existing project, that was created using cruft, run cruft update in the root of the project. If there are any updates, cruft will have you review them before applying. If you accept the changes cruft will apply them to your project and update the .cruft.json file for you. Tip Sometimes certain files just aren't good fits for updating. Such as test cases or __init__ files. You can tell cruft to always skip updating these files on a project by generating project with --skip cruft/__init__.py --skip tests arguments or manually adding them to a skip section within your .cruft.json file: { \"template\": \"https://github.com/timothycrosley/cookiecutter-python\", \"commit\": \"8a65a360d51250221193ed0ec5ed292e72b32b0b\", \"skip\": [ \"cruft/__init__.py\", \"tests\" ], ... } Or, if you have toml installed, you can add skip files directly to a tool.cruft section of your pyproject.toml file: [tool.cruft] skip = [\"cruft/__init__.py\", \"tests\"] Note that it is possible to use glob patterns for selecting the files to skip: { \"skip\": [ \"* / init .py\", \"tests/ \" ], ... }","title":"Updating a Project"},{"location":"#updating-values-of-template-variables","text":"cruft can also be used to update a project to use new values of template variables; avoiding the need to regenerate the project from sratch using cookiecutter . For example, imagine a project that was initially generated some while ago, and then later on, you want to change the values of some of the template variables, e.g. to change use_some_feature to \"yes\" or to change project_name to \"new-project-name\" . There are 2 ways this can be done, as described below.","title":"Updating Values of Template Variables"},{"location":"#update-variables-via-the-command-line","text":"You can perform the update directly via the command line if you have only a handful of simple variables. This will change use_some_feature to \"yes\" while leaving all other variables unchanged: cruft update --variables-to-update '{ \"use_some_feature\" : \"yes\" }' This will change both use_some_feature to \"yes\" and project_name to \"new-project-name\" (and still leaving all other variables unchanged): cruft update --variables-to-update '{ \"use_some_feature\" : \"yes\", \"project_name\" : \"new-project-name\" }' The provided argument must be a valid JSON string (i.e. using double quotes, no trailing comma etc.).","title":"Update Variables via the Command Line"},{"location":"#update-variables-via-a-cruft-file","text":"If you prefer to use and editor or you have many or complex variables, you can also perform the changes via providing an updated .cruft.json. # copy the existing cruft file to a temporary location (outside of your repo) cp .cruft.json ~/tmp/new-cruft.json # edit the file using your faviourite editor edit ~/tmp/new-cruft.json # perform the update # (this will also update your original .cruft.json automatically) cruft update --variables-to-update-file ~/tmp/new-cruft.json","title":"Update Variables via a Cruft File"},{"location":"#checking-a-project","text":"Checking to see if a project is missing a template update is as easy as running cruft check . If the project is out-of-date an error and exit code 1 will be returned. cruft check can be added to CI pipelines to ensure projects don't unintentionally drift.","title":"Checking a Project"},{"location":"#linking-an-existing-project","text":"Have an existing project that you created from a template in the past using Cookiecutter directly? You can link it to the template that was used to create it using: cruft link TEMPLATE_REPOSITORY . For example: cruft link https://github.com/timothycrosley/cookiecutter-python/ You can then specify the last commit of the template the project has been updated to be consistent with, or accept the default of using the latest commit from the template.","title":"Linking an Existing Project"},{"location":"#compute-the-diff","text":"With time, your boilerplate may end up being very different from the actual cookiecutter template. Cruft allows you to quickly see what changed in your local project compared to the template. It is as easy as running cruft diff . If any local file differs from the template, the diff will appear in your terminal in a similar fashion to git diff . The cruft diff command optionally accepts an --exit-code flag that will make cruft exit with a non-0 code should any diff is found. You can combine this flag with the skip section of your .cruft.json to make stricter CI checks that ensures any improvement to the template is always submitted upstream.","title":"Compute the diff"},{"location":"#automating-updates-with-github-actions","text":"If you have many repositories to manage, you can automate the change detection process with GitHub Actions. This example runs every Monday at 2am UTC and creates a new pull request if there are changes detected which a maintainer can accept or reject. It creates two PRs - one to pull in the new files to the repository and one to update the .cruft.json file only, which has the effect of rejecting the change from the upstream repository. Since Jan 2022, registries/organisations must explicitly grant the authority to create a pull request. This can be enabled on a per-organisation level, or a per-registry level for personal projects. See GitHub for more details. # /.github/workflows/cruft-update.yml name : Update repository with Cruft permissions : contents : write pull-requests : write on : schedule : - cron : \"0 2 * * 1\" # Every Monday at 2am jobs : update : runs-on : ubuntu-latest strategy : fail-fast : true matrix : include : - add-paths : . body : Use this to merge the changes to this repository. branch : cruft/update commit-message : \"chore: accept new Cruft update\" title : New updates detected with Cruft - add-paths : .cruft.json body : Use this to reject the changes in this repository. branch : cruft/reject commit-message : \"chore: reject new Cruft update\" title : Reject new updates detected with Cruft steps : - uses : actions/checkout@v3 - uses : actions/setup-python@v4 with : python-version : \"3.10\" - name : Install Cruft run : pip3 install cruft - name : Check if update is available continue-on-error : false id : check run : | CHANGES=0 if [ -f .cruft.json ]; then if ! cruft check; then CHANGES=1 fi else echo \"No .cruft.json file\" fi echo \"has_changes=$CHANGES\" >> \"$GITHUB_OUTPUT\" - name : Run update if available if : steps.check.outputs.has_changes == '1' run : | git config --global user.email \"you@example.com\" git config --global user.name \"GitHub\" cruft update --skip-apply-ask --refresh-private-variables git restore --staged . - name : Create pull request if : steps.check.outputs.has_changes == '1' uses : peter-evans/create-pull-request@v4 with : token : ${{ secrets.GITHUB_TOKEN }} add-paths : ${{ matrix.add-paths }} commit-message : ${{ matrix.commit-message }} branch : ${{ matrix.branch }} delete-branch : true branch-suffix : timestamp title : ${{ matrix.title }} body : | This is an autogenerated PR. ${{ matrix.body }} [Cruft](https://cruft.github.io/cruft/) has detected updates from the Cookiecutter repository.","title":"Automating updates with GitHub Actions"},{"location":"#why-create-cruft","text":"Since I first saw videos of quickly being used to automate Ubuntu application creation, I've had a love/hate relationship with these kinds of tools. I've used them for many projects and certainly seen them lead to productivity improvements. However, I've always felt like they were a double-edged sword. Sure, they would automate away the copying and pasting many would do to create projects. However, by doing so, they encouraged more code to be copied and pasted! Then, over time, you could easily be left with hundreds of projects that contained copy-and-pasted code with no way to easy way to update them. I created cruft to be a tool that recognized that balance between project creation and maintenance and provided mechanisms to keep built projects up-to-date. I hope you too find cruft useful! ~Timothy Crosley","title":"Why Create cruft?"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft Changelog 2.15.0 - 11 May 2023 Improved #57 : Improve how a project can be updated to use new values of template variables 2.14.0 - 4 April 2023 Implemented #57 : Accept cookiecutter arguments on the command line for update 2.13.0 - 4 April 2023 Implemented #172 : Add support for local extensions 2.12.0 - 28 December 2022 Uncapped version requirements (including Python) for greater compatiblity Fixed issue #166 : Fixed compatiblity with latest version of cookiecutter Implemented #184 : Store checkout parameter when using link command Improvements to update command 2.11.1 - 28 August 2022 Fixed issue #177 : cruft update can't apply diffs when git's diff.mnemonicprefix config is set 2.11.0 - 29 July 2022 Fixed issue #168 : Add support for typer v0.6+ Fixed issue #162 : Add support for cookiecutter v2 2.10.2 - 20 Apr 2022 Fixed issue #152 : Upgrade version of importlib-metadata 2.10.1 - 8 Nov 2021 Fixed missing dependency on importlib-metadata 2.10.0 - 7 Nov 2021 Fixed issue #41 : Add windows support Fixed issue #112 : Add support for generating the project with always skipped files on update Fixed issue #123 : Feature request: Faster implementation for cruft check Fixed issue #124 : cruft 2.9.0 on Pypi requires click <= 8.0.0 Fixed issue #131 : Feature request: support binary files patching 2.9.0 - 30 June 2021 Fixed issue #64 : Feature request: support globs for skipped files Fixed issue #101 : Update error if symlink is present in project Fixed issue #81 : cruft update leads to UnicodeDecodeError Fixed issue #115 : Warn when pyproject.toml exists but cannot be read 2.8.0 - 9 March 2021 Fixed issue #68 : Add support for cruft create/update in a sub directory in an existing repository Fixed issue #91 : Support Updating When Repo has Untracked Files 2.7.0 - 22 February 2021 Fixed issue #76 : diff.noprefix=yes breaks tests Fixed issue #92 : Store checkout value in cruft state 2.6.1 - 1 February 2021 Fixed issue #82 : error: git diff header lacks filename information when removing 1 leading pathname component 2.6.0 - 7 November 2020 Fixed issue #53 : Update fails on moved files, without clear error messages Fixed issue #67 : Update fails on new files Fixed issue #71 : Fix the order for cruft diff 2.5.0 - 1 October 2020 Fixed issue #58 : Add a diff command that compares the current project to the upstream cookiecutter 2.4.0 - 18 September 2020 Fixed issue #52 : Clarify error message when specified commit is missing from repo Fixed issue #55 : Add support for ssh connections to template repository Fixed issue #56 : Improve error message when providing incorrect credentials 2.3.0 - 16 August 2020 Fixed issue #46 : Cruft update fails to apply without providing conflits to resolve manually 2.2.0 - 16 August 2020 Fixed issue #44 : Cruft update can drop changes 2.1.0 - 13 August 2020 Fixed issue #42 : Cruft check fails if the current version of the project is ahead of the cookiecutter 2.0.0 - 12 August 2020 Implemented #31 : Moved from hug -> typer and refactored Python API. Implemented #39 : Simplify internals by fully droping Windows support beyond WSL. Fixed issue #7 : Incorrect CLI help documentation. Fixed issue #23 : Relative paths not supported. 1.4.0 - 11 August 2020 Fixed issue #21 : Improve messaging when diff is empty. Implemented #15 : Allow piping diff to an external utility. Implemented #33 : When possible, use git apply instead of patch . 1.3.0 - 9 August 2020 Fixed issue #8 : Fall back to no-backup if patch doesn't support --merge. Fixed issue #11 : Config file flag --config_file broken. Implemented #24 : Allow cruft update to specify a branch of the cookiecutter repo. Implemented #10 : Provide a mechanism to choose template version. Internal: - Refactored api module into a collection of smaller better scoped modules. 1.2.0 - 7 August 2020 Fixed issue #26 : Support for Directory as there are multiple templates in single repo Fixed issue #18 & #13 : Commands fail with OSError randomly on windows 1.1.2 - 3 October 2019 Fixed Issue #3 : Patch failed to apply. Updated to use pathlib. Improved pyproject.toml skip_files, avoiding duplication into .cruft.json file. 1.1.1 - 25 September 2019 Added optional support for reading skip options from pyproject.toml . 1.1.0 - 24 September 2019 Added link command to link existing repositories to the Cookiecutter template that created them. Added skip option to .cruft.json file allowing template updates to be skipped per a repository. Improved patch applying from template updates. Added an interactive option on the update command to skip an individual update, while marking a repository as up-to-date. 1.0.0 - 23 September 2019 Initial API stable release.","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#2150-11-may-2023","text":"Improved #57 : Improve how a project can be updated to use new values of template variables","title":"2.15.0 - 11 May 2023"},{"location":"CHANGELOG/#2140-4-april-2023","text":"Implemented #57 : Accept cookiecutter arguments on the command line for update","title":"2.14.0 - 4 April 2023"},{"location":"CHANGELOG/#2130-4-april-2023","text":"Implemented #172 : Add support for local extensions","title":"2.13.0 - 4 April 2023"},{"location":"CHANGELOG/#2120-28-december-2022","text":"Uncapped version requirements (including Python) for greater compatiblity Fixed issue #166 : Fixed compatiblity with latest version of cookiecutter Implemented #184 : Store checkout parameter when using link command Improvements to update command","title":"2.12.0 - 28 December 2022"},{"location":"CHANGELOG/#2111-28-august-2022","text":"Fixed issue #177 : cruft update can't apply diffs when git's diff.mnemonicprefix config is set","title":"2.11.1 - 28 August 2022"},{"location":"CHANGELOG/#2110-29-july-2022","text":"Fixed issue #168 : Add support for typer v0.6+ Fixed issue #162 : Add support for cookiecutter v2","title":"2.11.0 - 29 July 2022"},{"location":"CHANGELOG/#2102-20-apr-2022","text":"Fixed issue #152 : Upgrade version of importlib-metadata","title":"2.10.2 - 20 Apr 2022"},{"location":"CHANGELOG/#2101-8-nov-2021","text":"Fixed missing dependency on importlib-metadata","title":"2.10.1 - 8 Nov 2021"},{"location":"CHANGELOG/#2100-7-nov-2021","text":"Fixed issue #41 : Add windows support Fixed issue #112 : Add support for generating the project with always skipped files on update Fixed issue #123 : Feature request: Faster implementation for cruft check Fixed issue #124 : cruft 2.9.0 on Pypi requires click <= 8.0.0 Fixed issue #131 : Feature request: support binary files patching","title":"2.10.0 - 7 Nov 2021"},{"location":"CHANGELOG/#290-30-june-2021","text":"Fixed issue #64 : Feature request: support globs for skipped files Fixed issue #101 : Update error if symlink is present in project Fixed issue #81 : cruft update leads to UnicodeDecodeError Fixed issue #115 : Warn when pyproject.toml exists but cannot be read","title":"2.9.0 - 30 June 2021"},{"location":"CHANGELOG/#280-9-march-2021","text":"Fixed issue #68 : Add support for cruft create/update in a sub directory in an existing repository Fixed issue #91 : Support Updating When Repo has Untracked Files","title":"2.8.0 - 9 March 2021"},{"location":"CHANGELOG/#270-22-february-2021","text":"Fixed issue #76 : diff.noprefix=yes breaks tests Fixed issue #92 : Store checkout value in cruft state","title":"2.7.0 - 22 February 2021"},{"location":"CHANGELOG/#261-1-february-2021","text":"Fixed issue #82 : error: git diff header lacks filename information when removing 1 leading pathname component","title":"2.6.1 - 1 February 2021"},{"location":"CHANGELOG/#260-7-november-2020","text":"Fixed issue #53 : Update fails on moved files, without clear error messages Fixed issue #67 : Update fails on new files Fixed issue #71 : Fix the order for cruft diff","title":"2.6.0 - 7 November 2020"},{"location":"CHANGELOG/#250-1-october-2020","text":"Fixed issue #58 : Add a diff command that compares the current project to the upstream cookiecutter","title":"2.5.0 - 1 October 2020"},{"location":"CHANGELOG/#240-18-september-2020","text":"Fixed issue #52 : Clarify error message when specified commit is missing from repo Fixed issue #55 : Add support for ssh connections to template repository Fixed issue #56 : Improve error message when providing incorrect credentials","title":"2.4.0 - 18 September 2020"},{"location":"CHANGELOG/#230-16-august-2020","text":"Fixed issue #46 : Cruft update fails to apply without providing conflits to resolve manually","title":"2.3.0 - 16 August 2020"},{"location":"CHANGELOG/#220-16-august-2020","text":"Fixed issue #44 : Cruft update can drop changes","title":"2.2.0 - 16 August 2020"},{"location":"CHANGELOG/#210-13-august-2020","text":"Fixed issue #42 : Cruft check fails if the current version of the project is ahead of the cookiecutter","title":"2.1.0 - 13 August 2020"},{"location":"CHANGELOG/#200-12-august-2020","text":"Implemented #31 : Moved from hug -> typer and refactored Python API. Implemented #39 : Simplify internals by fully droping Windows support beyond WSL. Fixed issue #7 : Incorrect CLI help documentation. Fixed issue #23 : Relative paths not supported.","title":"2.0.0 - 12 August 2020"},{"location":"CHANGELOG/#140-11-august-2020","text":"Fixed issue #21 : Improve messaging when diff is empty. Implemented #15 : Allow piping diff to an external utility. Implemented #33 : When possible, use git apply instead of patch .","title":"1.4.0 - 11 August 2020"},{"location":"CHANGELOG/#130-9-august-2020","text":"Fixed issue #8 : Fall back to no-backup if patch doesn't support --merge. Fixed issue #11 : Config file flag --config_file broken. Implemented #24 : Allow cruft update to specify a branch of the cookiecutter repo. Implemented #10 : Provide a mechanism to choose template version. Internal: - Refactored api module into a collection of smaller better scoped modules.","title":"1.3.0 - 9 August 2020"},{"location":"CHANGELOG/#120-7-august-2020","text":"Fixed issue #26 : Support for Directory as there are multiple templates in single repo Fixed issue #18 & #13 : Commands fail with OSError randomly on windows","title":"1.2.0 - 7 August 2020"},{"location":"CHANGELOG/#112-3-october-2019","text":"Fixed Issue #3 : Patch failed to apply. Updated to use pathlib. Improved pyproject.toml skip_files, avoiding duplication into .cruft.json file.","title":"1.1.2 - 3 October 2019"},{"location":"CHANGELOG/#111-25-september-2019","text":"Added optional support for reading skip options from pyproject.toml .","title":"1.1.1 - 25 September 2019"},{"location":"CHANGELOG/#110-24-september-2019","text":"Added link command to link existing repositories to the Cookiecutter template that created them. Added skip option to .cruft.json file allowing template updates to be skipped per a repository. Improved patch applying from template updates. Added an interactive option on the update command to skip an individual update, while marking a repository as up-to-date.","title":"1.1.0 - 24 September 2019"},{"location":"CHANGELOG/#100-23-september-2019","text":"Initial API stable release.","title":"1.0.0 - 23 September 2019"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to cruft Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting cruft set up for local development The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-cruft","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to cruft"},{"location":"docs/contributing/1.-contributing-guide/#getting-cruft-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install","title":"Getting cruft set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Sambhav Kothari ( @samj1912 ) Timothy Crosley ( @timothycrosley ) Special Mentions Peter Olson ( @peter200lx ) for coming up with the main implementation idea behind cruft. Notable Bug Reporters - Code Contributors Peter Olson ( @peter200lx ) Medhat Assaad ( @massaad ) Appunni M ( @appunni-dishq ) Gilbert Gilb's ( @gilbsgilbs ) Documenters - A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Sambhav Kothari ( @samj1912 ) Timothy Crosley ( @timothycrosley )","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#special-mentions","text":"Peter Olson ( @peter200lx ) for coming up with the main implementation idea behind cruft.","title":"Special Mentions"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"Peter Olson ( @peter200lx ) Medhat Assaad ( @massaad ) Appunni M ( @appunni-dishq ) Gilbert Gilb's ( @gilbsgilbs )","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"Documenters"},{"location":"reference/cruft/","text":"Module cruft cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._commands import check , create , diff , link , update from cruft._version import __version__ __all__ = [ \"create\" , \"check\" , \"diff\" , \"update\" , \"link\" , \"__version__\" ] Sub-modules cruft.exceptions Variables __version__ Functions check def check ( project_dir : pathlib . Path = PosixPath ( '.' ), checkout : Union [ str , NoneType ] = None , strict : bool = True ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. View Source @example () def check ( project_dir : Path = Path ( \".\" ), checkout : Optional [ str ] = None , strict : bool = True ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project.\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) with AltTemporaryDirectory ( cruft_state . get ( \"directory\" )) as cookiecutter_template_dir : with utils . cookiecutter . get_cookiecutter_repo ( cruft_state [ \"template\" ] , Path ( cookiecutter_template_dir ), checkout , filter = \"blob:none\" , no_checkout = True , ) as repo : last_commit = repo . head . object . hexsha if utils . cruft . is_project_updated ( repo , cruft_state [ \"commit\" ] , last_commit , strict ) : typer . secho ( \"SUCCESS: Good work! Project's cruft is up to date \" \"and as clean as possible :).\" , fg = typer . colors . GREEN , ) return True typer . secho ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" , fg = typer . colors . RED , ) return False create def create ( template_git_url : str , output_dir : pathlib . Path = PosixPath ( '.' ), config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , extra_context_file : Union [ pathlib . Path , NoneType ] = None , no_input : bool = True , directory : Union [ str , NoneType ] = None , checkout : Union [ str , NoneType ] = None , overwrite_if_exists : bool = False , skip : Union [ List [ str ], NoneType ] = None ) -> pathlib . Path Expand a Git based Cookiecutter template into a new project on disk. View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def create ( template_git_url : str , output_dir : Path = Path ( \".\" ), config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , extra_context_file : Optional [ Path ] = None , no_input : bool = True , directory : Optional [ str ] = None , checkout : Optional [ str ] = None , overwrite_if_exists : bool = False , skip : Optional [ List[str ] ] = None , ) -> Path : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" template_git_url = utils . cookiecutter . resolve_template_url ( template_git_url ) with AltTemporaryDirectory ( directory ) as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) with utils . cookiecutter . get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir , checkout ) as repo : last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory if extra_context_file : extra_context = utils . cookiecutter . get_extra_context_from_file ( extra_context_file ) context = utils . cookiecutter . generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) project_dir = Path ( generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = str ( output_dir ), ) ) cruft_content = { \"template\" : template_git_url , \"commit\" : last_commit , \"checkout\" : checkout , \"context\" : context , \"directory\" : directory , } if skip : cruft_content [ \"skip\" ] = skip # After generating the project - save the cruft state # into the cruft file . ( project_dir / \".cruft.json\" ). write_text ( utils . cruft . json_dumps ( cruft_content )) return project_dir diff def diff ( project_dir : pathlib . Path = PosixPath ( '.' ), exit_code : bool = False , checkout : Union [ str , NoneType ] = None ) -> bool Show the diff between the project and the linked Cookiecutter template View Source def diff ( project_dir : Path = Path ( \".\" ), exit_code : bool = False , checkout : Optional [ str ] = None ) -> bool : \"\"\"Show the diff between the project and the linked Cookiecutter template\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) checkout = checkout or cruft_state . get ( \"commit\" ) has_diff = False with AltTemporaryDirectory ( cruft_state . get ( \"directory\" )) as tmpdir_ : tmpdir = Path ( tmpdir_ ) repo_dir = tmpdir / \"repo\" remote_template_dir = tmpdir / \"remote\" local_template_dir = tmpdir / \"local\" # Create all the directories remote_template_dir . mkdir ( parents = True , exist_ok = True ) local_template_dir . mkdir ( parents = True , exist_ok = True ) # Let 's clone the template with utils.cookiecutter.get_cookiecutter_repo( cruft_state[\"template\"], repo_dir, checkout=checkout ) as repo: # We generate the template for the revision expected by the project utils.generate.cookiecutter_template( output_dir=remote_template_dir, repo=repo, cruft_state=cruft_state, project_dir=project_dir, checkout=checkout, update_deleted_paths=True, ) # Then we create a new tree with each file in the template that also exist # locally. for path in sorted(remote_template_dir.glob(\"**/*\")): relative_path = path.relative_to(remote_template_dir) local_path = project_dir / relative_path destination = local_template_dir / relative_path if path.is_file(): shutil.copy(str(local_path), str(destination)) else: destination.mkdir(parents=True, exist_ok=True) destination.chmod(local_path.stat().st_mode) # Finally we can compute and print the diff. diff = utils.diff.get_diff(local_template_dir, remote_template_dir) if diff.strip(): has_diff = True if exit_code or not sys.stdout.isatty(): # The current shell doesn' t run on a TTY or the \"--exit-code\" flag # is set . This means we 're probably not displaying the diff to an # end-user. Let' s just output the sanitized version of the diff . # # Note that we can 't delegate this check to \"git diff\" command # because it would show absolute paths to files as we' re working in # temporary , non - gitted directories . Doing so would prevent the user # from applying the patch later on as the temporary directories wouldn 't # exist anymore. typer.echo(diff, nl=False) else: # We' re outputing the diff to a real user . We can delegate the job # to git diff so that they can benefit from coloration and paging . # Ouputing absolute paths is less of a concern although it would be # better to find a way to make git shrink those paths . utils . diff . display_diff ( local_template_dir , remote_template_dir ) return not ( has_diff and exit_code ) link def link ( template_git_url : str , project_dir : pathlib . Path = PosixPath ( '.' ), checkout : Union [ str , NoneType ] = None , no_input : bool = True , config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , directory : Union [ str , NoneType ] = None ) -> bool Links an existing project created from a template, to the template it was created from. View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def link ( template_git_url : str , project_dir : Path = Path ( \".\" ), checkout : Optional [ str ] = None , no_input : bool = True , config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , directory : Optional [ str ] = None , ) -> bool : \"\"\"Links an existing project created from a template, to the template it was created from.\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir , exists = False ) template_git_url = utils . cookiecutter . resolve_template_url ( template_git_url ) with AltTemporaryDirectory ( directory ) as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) with utils . cookiecutter . get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir , checkout ) as repo : last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory context = utils . cookiecutter . generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) if no_input : use_commit = last_commit else : typer . echo ( f \"Linking against the commit: {last_commit}\" f \" which corresponds with the git reference: {checkout}\" ) typer . echo ( \"Press enter to link against this commit or provide an alternative commit.\" ) use_commit = typer . prompt ( \"Link to template at commit\" , default = last_commit ) cruft_file . write_text ( utils . cruft . json_dumps ( { \"template\" : template_git_url , \"commit\" : use_commit , \"checkout\" : checkout , \"context\" : context , \"directory\" : directory , } ) ) return True update def update ( project_dir : pathlib . Path = PosixPath ( '.' ), cookiecutter_input : bool = False , refresh_private_variables : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Union [ str , NoneType ] = None , strict : bool = True , allow_untracked_files : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , extra_context_file : Union [ pathlib . Path , NoneType ] = None ) -> bool Update specified project's cruft to the latest and greatest release. View Source @ example ( skip_apply_ask = False ) @ example () def update ( project_dir : Path = Path ( \".\" ), cookiecutter_input : bool = False , refresh_private_variables : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Optional [ str ] = None , strict : bool = True , allow_untracked_files : bool = False , extra_context : Optional [ Dict [ str , Any ]] = None , extra_context_file : Optional [ Path ] = None , ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir ) if extra_context_file : if extra_context_file . samefile ( cruft_file ): typer . secho ( f \"The file path given to --variables-to-update-file cannot be the same as the\" f \" project's cruft file ({cruft_file}), as the update process needs\" f \" to know the old/original values of variables as well. Please specify a\" f \" different path, and the project's cruft file will be updated as\" f \" part of the process.\" , fg = typer . colors . RED , ) return False extra_context_from_cli = extra_context with open ( extra_context_file , \"r\" ) as extra_context_fp : extra_context = json . load ( extra_context_fp ) or {} extra_context = extra_context . get ( \"context\" ) or {} extra_context = extra_context . get ( \"cookiecutter\" ) or {} if extra_context_from_cli : extra_context . update ( extra_context_from_cli ) # If the project dir is a git repository, we ensure # that the user has a clean working directory before proceeding. if not _is_project_repo_clean ( project_dir , allow_untracked_files ): typer . secho ( \"Cruft cannot apply updates on an unclean git project.\" \" Please make sure your git working tree is clean before proceeding.\" , fg = typer . colors . RED , ) return False cruft_state = json . loads ( cruft_file . read_text ()) directory = cruft_state . get ( \"directory\" , \"\" ) if directory : directory = str ( Path ( \"repo\" ) / directory ) else : directory = \"repo\" with AltTemporaryDirectory ( directory ) as tmpdir_ : # Initial setup tmpdir = Path ( tmpdir_ ) repo_dir = tmpdir / \"repo\" current_template_dir = tmpdir / \"current_template\" new_template_dir = tmpdir / \"new_template\" deleted_paths : Set [ Path ] = set () # Clone the template with utils . cookiecutter . get_cookiecutter_repo ( cruft_state [ \"template\" ], repo_dir , checkout ) as repo : last_commit = repo . head . object . hexsha # Bail early if the repo is already up to date and no inputs are asked if not ( extra_context or cookiecutter_input or refresh_private_variables ) and utils . cruft . is_project_updated ( repo , cruft_state [ \"commit\" ], last_commit , strict ): typer . secho ( \"Nothing to do, project's cruft is already up to date!\" , fg = typer . colors . GREEN ) return True # Generate clean outputs via the cookiecutter # from the current cruft state commit of the cookiecutter and the updated # cookiecutter. # For the current cruft state, we do not try to update the cookiecutter_input # because we want to keep the current context input intact. _ = utils . generate . cookiecutter_template ( output_dir = current_template_dir , repo = repo , cruft_state = cruft_state , project_dir = project_dir , checkout = cruft_state [ \"commit\" ], deleted_paths = deleted_paths , update_deleted_paths = True , ) # Remove private variables from cruft_state to refresh their values # from the cookiecutter template config if refresh_private_variables : _clean_cookiecutter_private_variables ( cruft_state ) # Add new input data from command line to cookiecutter context if extra_context : extra = cruft_state [ \"context\" ][ \"cookiecutter\" ] for k , v in extra_context . items (): extra [ k ] = v new_context = utils . generate . cookiecutter_template ( output_dir = new_template_dir , repo = repo , cruft_state = cruft_state , project_dir = project_dir , cookiecutter_input = cookiecutter_input , checkout = last_commit , deleted_paths = deleted_paths , ) # Given the two versions of the cookiecutter outputs based # on the current project's context we calculate the diff and # apply the updates to the current project. if _apply_project_updates ( current_template_dir , new_template_dir , project_dir , skip_update , skip_apply_ask , allow_untracked_files , ): # Update the cruft state and dump the new state # to the cruft file cruft_state [ \"commit\" ] = last_commit cruft_state [ \"checkout\" ] = checkout cruft_state [ \"context\" ] = new_context cruft_file . write_text ( utils . cruft . json_dumps ( cruft_state )) typer . secho ( \"Good work! Project's cruft has been updated and is as clean as possible!\" , fg = typer . colors . GREEN , ) return True","title":"Index"},{"location":"reference/cruft/#module-cruft","text":"cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._commands import check , create , diff , link , update from cruft._version import __version__ __all__ = [ \"create\" , \"check\" , \"diff\" , \"update\" , \"link\" , \"__version__\" ]","title":"Module cruft"},{"location":"reference/cruft/#sub-modules","text":"cruft.exceptions","title":"Sub-modules"},{"location":"reference/cruft/#variables","text":"__version__","title":"Variables"},{"location":"reference/cruft/#functions","text":"","title":"Functions"},{"location":"reference/cruft/#check","text":"def check ( project_dir : pathlib . Path = PosixPath ( '.' ), checkout : Union [ str , NoneType ] = None , strict : bool = True ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. View Source @example () def check ( project_dir : Path = Path ( \".\" ), checkout : Optional [ str ] = None , strict : bool = True ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project.\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) with AltTemporaryDirectory ( cruft_state . get ( \"directory\" )) as cookiecutter_template_dir : with utils . cookiecutter . get_cookiecutter_repo ( cruft_state [ \"template\" ] , Path ( cookiecutter_template_dir ), checkout , filter = \"blob:none\" , no_checkout = True , ) as repo : last_commit = repo . head . object . hexsha if utils . cruft . is_project_updated ( repo , cruft_state [ \"commit\" ] , last_commit , strict ) : typer . secho ( \"SUCCESS: Good work! Project's cruft is up to date \" \"and as clean as possible :).\" , fg = typer . colors . GREEN , ) return True typer . secho ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" , fg = typer . colors . RED , ) return False","title":"check"},{"location":"reference/cruft/#create","text":"def create ( template_git_url : str , output_dir : pathlib . Path = PosixPath ( '.' ), config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , extra_context_file : Union [ pathlib . Path , NoneType ] = None , no_input : bool = True , directory : Union [ str , NoneType ] = None , checkout : Union [ str , NoneType ] = None , overwrite_if_exists : bool = False , skip : Union [ List [ str ], NoneType ] = None ) -> pathlib . Path Expand a Git based Cookiecutter template into a new project on disk. View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def create ( template_git_url : str , output_dir : Path = Path ( \".\" ), config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , extra_context_file : Optional [ Path ] = None , no_input : bool = True , directory : Optional [ str ] = None , checkout : Optional [ str ] = None , overwrite_if_exists : bool = False , skip : Optional [ List[str ] ] = None , ) -> Path : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" template_git_url = utils . cookiecutter . resolve_template_url ( template_git_url ) with AltTemporaryDirectory ( directory ) as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) with utils . cookiecutter . get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir , checkout ) as repo : last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory if extra_context_file : extra_context = utils . cookiecutter . get_extra_context_from_file ( extra_context_file ) context = utils . cookiecutter . generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) project_dir = Path ( generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = str ( output_dir ), ) ) cruft_content = { \"template\" : template_git_url , \"commit\" : last_commit , \"checkout\" : checkout , \"context\" : context , \"directory\" : directory , } if skip : cruft_content [ \"skip\" ] = skip # After generating the project - save the cruft state # into the cruft file . ( project_dir / \".cruft.json\" ). write_text ( utils . cruft . json_dumps ( cruft_content )) return project_dir","title":"create"},{"location":"reference/cruft/#diff","text":"def diff ( project_dir : pathlib . Path = PosixPath ( '.' ), exit_code : bool = False , checkout : Union [ str , NoneType ] = None ) -> bool Show the diff between the project and the linked Cookiecutter template View Source def diff ( project_dir : Path = Path ( \".\" ), exit_code : bool = False , checkout : Optional [ str ] = None ) -> bool : \"\"\"Show the diff between the project and the linked Cookiecutter template\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) checkout = checkout or cruft_state . get ( \"commit\" ) has_diff = False with AltTemporaryDirectory ( cruft_state . get ( \"directory\" )) as tmpdir_ : tmpdir = Path ( tmpdir_ ) repo_dir = tmpdir / \"repo\" remote_template_dir = tmpdir / \"remote\" local_template_dir = tmpdir / \"local\" # Create all the directories remote_template_dir . mkdir ( parents = True , exist_ok = True ) local_template_dir . mkdir ( parents = True , exist_ok = True ) # Let 's clone the template with utils.cookiecutter.get_cookiecutter_repo( cruft_state[\"template\"], repo_dir, checkout=checkout ) as repo: # We generate the template for the revision expected by the project utils.generate.cookiecutter_template( output_dir=remote_template_dir, repo=repo, cruft_state=cruft_state, project_dir=project_dir, checkout=checkout, update_deleted_paths=True, ) # Then we create a new tree with each file in the template that also exist # locally. for path in sorted(remote_template_dir.glob(\"**/*\")): relative_path = path.relative_to(remote_template_dir) local_path = project_dir / relative_path destination = local_template_dir / relative_path if path.is_file(): shutil.copy(str(local_path), str(destination)) else: destination.mkdir(parents=True, exist_ok=True) destination.chmod(local_path.stat().st_mode) # Finally we can compute and print the diff. diff = utils.diff.get_diff(local_template_dir, remote_template_dir) if diff.strip(): has_diff = True if exit_code or not sys.stdout.isatty(): # The current shell doesn' t run on a TTY or the \"--exit-code\" flag # is set . This means we 're probably not displaying the diff to an # end-user. Let' s just output the sanitized version of the diff . # # Note that we can 't delegate this check to \"git diff\" command # because it would show absolute paths to files as we' re working in # temporary , non - gitted directories . Doing so would prevent the user # from applying the patch later on as the temporary directories wouldn 't # exist anymore. typer.echo(diff, nl=False) else: # We' re outputing the diff to a real user . We can delegate the job # to git diff so that they can benefit from coloration and paging . # Ouputing absolute paths is less of a concern although it would be # better to find a way to make git shrink those paths . utils . diff . display_diff ( local_template_dir , remote_template_dir ) return not ( has_diff and exit_code )","title":"diff"},{"location":"reference/cruft/#link","text":"def link ( template_git_url : str , project_dir : pathlib . Path = PosixPath ( '.' ), checkout : Union [ str , NoneType ] = None , no_input : bool = True , config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , directory : Union [ str , NoneType ] = None ) -> bool Links an existing project created from a template, to the template it was created from. View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def link ( template_git_url : str , project_dir : Path = Path ( \".\" ), checkout : Optional [ str ] = None , no_input : bool = True , config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , directory : Optional [ str ] = None , ) -> bool : \"\"\"Links an existing project created from a template, to the template it was created from.\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir , exists = False ) template_git_url = utils . cookiecutter . resolve_template_url ( template_git_url ) with AltTemporaryDirectory ( directory ) as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) with utils . cookiecutter . get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir , checkout ) as repo : last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory context = utils . cookiecutter . generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) if no_input : use_commit = last_commit else : typer . echo ( f \"Linking against the commit: {last_commit}\" f \" which corresponds with the git reference: {checkout}\" ) typer . echo ( \"Press enter to link against this commit or provide an alternative commit.\" ) use_commit = typer . prompt ( \"Link to template at commit\" , default = last_commit ) cruft_file . write_text ( utils . cruft . json_dumps ( { \"template\" : template_git_url , \"commit\" : use_commit , \"checkout\" : checkout , \"context\" : context , \"directory\" : directory , } ) ) return True","title":"link"},{"location":"reference/cruft/#update","text":"def update ( project_dir : pathlib . Path = PosixPath ( '.' ), cookiecutter_input : bool = False , refresh_private_variables : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Union [ str , NoneType ] = None , strict : bool = True , allow_untracked_files : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , extra_context_file : Union [ pathlib . Path , NoneType ] = None ) -> bool Update specified project's cruft to the latest and greatest release. View Source @ example ( skip_apply_ask = False ) @ example () def update ( project_dir : Path = Path ( \".\" ), cookiecutter_input : bool = False , refresh_private_variables : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Optional [ str ] = None , strict : bool = True , allow_untracked_files : bool = False , extra_context : Optional [ Dict [ str , Any ]] = None , extra_context_file : Optional [ Path ] = None , ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" cruft_file = utils . cruft . get_cruft_file ( project_dir ) if extra_context_file : if extra_context_file . samefile ( cruft_file ): typer . secho ( f \"The file path given to --variables-to-update-file cannot be the same as the\" f \" project's cruft file ({cruft_file}), as the update process needs\" f \" to know the old/original values of variables as well. Please specify a\" f \" different path, and the project's cruft file will be updated as\" f \" part of the process.\" , fg = typer . colors . RED , ) return False extra_context_from_cli = extra_context with open ( extra_context_file , \"r\" ) as extra_context_fp : extra_context = json . load ( extra_context_fp ) or {} extra_context = extra_context . get ( \"context\" ) or {} extra_context = extra_context . get ( \"cookiecutter\" ) or {} if extra_context_from_cli : extra_context . update ( extra_context_from_cli ) # If the project dir is a git repository, we ensure # that the user has a clean working directory before proceeding. if not _is_project_repo_clean ( project_dir , allow_untracked_files ): typer . secho ( \"Cruft cannot apply updates on an unclean git project.\" \" Please make sure your git working tree is clean before proceeding.\" , fg = typer . colors . RED , ) return False cruft_state = json . loads ( cruft_file . read_text ()) directory = cruft_state . get ( \"directory\" , \"\" ) if directory : directory = str ( Path ( \"repo\" ) / directory ) else : directory = \"repo\" with AltTemporaryDirectory ( directory ) as tmpdir_ : # Initial setup tmpdir = Path ( tmpdir_ ) repo_dir = tmpdir / \"repo\" current_template_dir = tmpdir / \"current_template\" new_template_dir = tmpdir / \"new_template\" deleted_paths : Set [ Path ] = set () # Clone the template with utils . cookiecutter . get_cookiecutter_repo ( cruft_state [ \"template\" ], repo_dir , checkout ) as repo : last_commit = repo . head . object . hexsha # Bail early if the repo is already up to date and no inputs are asked if not ( extra_context or cookiecutter_input or refresh_private_variables ) and utils . cruft . is_project_updated ( repo , cruft_state [ \"commit\" ], last_commit , strict ): typer . secho ( \"Nothing to do, project's cruft is already up to date!\" , fg = typer . colors . GREEN ) return True # Generate clean outputs via the cookiecutter # from the current cruft state commit of the cookiecutter and the updated # cookiecutter. # For the current cruft state, we do not try to update the cookiecutter_input # because we want to keep the current context input intact. _ = utils . generate . cookiecutter_template ( output_dir = current_template_dir , repo = repo , cruft_state = cruft_state , project_dir = project_dir , checkout = cruft_state [ \"commit\" ], deleted_paths = deleted_paths , update_deleted_paths = True , ) # Remove private variables from cruft_state to refresh their values # from the cookiecutter template config if refresh_private_variables : _clean_cookiecutter_private_variables ( cruft_state ) # Add new input data from command line to cookiecutter context if extra_context : extra = cruft_state [ \"context\" ][ \"cookiecutter\" ] for k , v in extra_context . items (): extra [ k ] = v new_context = utils . generate . cookiecutter_template ( output_dir = new_template_dir , repo = repo , cruft_state = cruft_state , project_dir = project_dir , cookiecutter_input = cookiecutter_input , checkout = last_commit , deleted_paths = deleted_paths , ) # Given the two versions of the cookiecutter outputs based # on the current project's context we calculate the diff and # apply the updates to the current project. if _apply_project_updates ( current_template_dir , new_template_dir , project_dir , skip_update , skip_apply_ask , allow_untracked_files , ): # Update the cruft state and dump the new state # to the cruft file cruft_state [ \"commit\" ] = last_commit cruft_state [ \"checkout\" ] = checkout cruft_state [ \"context\" ] = new_context cruft_file . write_text ( utils . cruft . json_dumps ( cruft_state )) typer . secho ( \"Good work! Project's cruft has been updated and is as clean as possible!\" , fg = typer . colors . GREEN , ) return True","title":"update"},{"location":"reference/cruft/exceptions/","text":"Module cruft.exceptions Contains all custom exceptions raised by cruft. View Source \"\"\"Contains all custom exceptions raised by cruft.\"\"\" from pathlib import Path from typing import Union from click import ClickException class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\" class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a Cookiecutter template in ` { directory } ` !\" ) self . directory = directory class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a `.cruft.json` state file in ` { directory } ` !\" ) self . directory = directory class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location : Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super () . __init__ ( f \"`.cruft.json` is already defined at ` { file_location } ` !\" ) self . file_location = file_location class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo : str , details : str = \"\" ): self . cookiecutter_repo = cookiecutter_repo super () . __init__ ( f \"Unable to initialize the cookiecutter using { cookiecutter_repo } ! { details . strip () } \" ) class ChangesetUnicodeError ( CruftError ): \"\"\"Raised when `cruft update` is unable to generate the change\"\"\" def __init__ ( self ): super () . __init__ ( ( \"Unable to interpret changes between current project and cookiecutter template as \" \"unicode. Typically a result of hidden binary files in project folder.\" ) ) Classes ChangesetUnicodeError class ChangesetUnicodeError ( ) Raised when cruft update is unable to generate the change View Source class ChangesetUnicodeError ( CruftError ): \"\"\"Raised when `cruft update` is unable to generate the change\"\"\" def __init__ ( self ): super (). __init__ ( ( \"Unable to interpret changes between current project and cookiecutter template as \" \"unicode. Typically a result of hidden binary files in project folder.\" ) ) Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message show def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. CruftAlreadyPresent class CruftAlreadyPresent ( file_location : Union [ str , pathlib . Path ] ) Raised when there is an attempt to create a new .cruft.json file but one already exists. View Source class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location: Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super (). __init__ ( f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message show def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. CruftError class CruftError ( message : str ) The base exception for any error originating from the cruft project. View Source class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\" Ancestors (in MRO) click.exceptions.ClickException builtins.Exception builtins.BaseException Descendants cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound cruft.exceptions.CruftAlreadyPresent cruft.exceptions.InvalidCookiecutterRepository cruft.exceptions.ChangesetUnicodeError Class variables args exit_code Methods format_message def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message show def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidCookiecutterRepository class InvalidCookiecutterRepository ( cookiecutter_repo : str , details : str = '' ) Raised when an invalid cookiecutter repository is provided. View Source class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo: str , details: str = \"\" ): self . cookiecutter_repo = cookiecutter_repo super (). __init__ ( f \"Unable to initialize the cookiecutter using {cookiecutter_repo}! {details.strip()}\" ) Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message show def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NoCruftFound class NoCruftFound ( directory : Union [ str , pathlib . Path ] ) Raised when no .cruft.json state is found in the current directory. View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message show def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnableToFindCookiecutterTemplate class UnableToFindCookiecutterTemplate ( directory : Union [ str , pathlib . Path ] ) Raised when Cruft is unable to find a cookiecutter template. View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message show def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/cruft/exceptions/#module-cruftexceptions","text":"Contains all custom exceptions raised by cruft. View Source \"\"\"Contains all custom exceptions raised by cruft.\"\"\" from pathlib import Path from typing import Union from click import ClickException class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\" class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a Cookiecutter template in ` { directory } ` !\" ) self . directory = directory class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a `.cruft.json` state file in ` { directory } ` !\" ) self . directory = directory class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location : Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super () . __init__ ( f \"`.cruft.json` is already defined at ` { file_location } ` !\" ) self . file_location = file_location class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo : str , details : str = \"\" ): self . cookiecutter_repo = cookiecutter_repo super () . __init__ ( f \"Unable to initialize the cookiecutter using { cookiecutter_repo } ! { details . strip () } \" ) class ChangesetUnicodeError ( CruftError ): \"\"\"Raised when `cruft update` is unable to generate the change\"\"\" def __init__ ( self ): super () . __init__ ( ( \"Unable to interpret changes between current project and cookiecutter template as \" \"unicode. Typically a result of hidden binary files in project folder.\" ) )","title":"Module cruft.exceptions"},{"location":"reference/cruft/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/cruft/exceptions/#changesetunicodeerror","text":"class ChangesetUnicodeError ( ) Raised when cruft update is unable to generate the change View Source class ChangesetUnicodeError ( CruftError ): \"\"\"Raised when `cruft update` is unable to generate the change\"\"\" def __init__ ( self ): super (). __init__ ( ( \"Unable to interpret changes between current project and cookiecutter template as \" \"unicode. Typically a result of hidden binary files in project folder.\" ) )","title":"ChangesetUnicodeError"},{"location":"reference/cruft/exceptions/#ancestors-in-mro","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message","text":"def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show","text":"def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#cruftalreadypresent","text":"class CruftAlreadyPresent ( file_location : Union [ str , pathlib . Path ] ) Raised when there is an attempt to create a new .cruft.json file but one already exists. View Source class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location: Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super (). __init__ ( f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location","title":"CruftAlreadyPresent"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_1","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_1","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_1","text":"def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_1","text":"def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#crufterror","text":"class CruftError ( message : str ) The base exception for any error originating from the cruft project. View Source class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\"","title":"CruftError"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_2","text":"click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#descendants","text":"cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound cruft.exceptions.CruftAlreadyPresent cruft.exceptions.InvalidCookiecutterRepository cruft.exceptions.ChangesetUnicodeError","title":"Descendants"},{"location":"reference/cruft/exceptions/#class-variables_2","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_2","text":"def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_2","text":"def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#invalidcookiecutterrepository","text":"class InvalidCookiecutterRepository ( cookiecutter_repo : str , details : str = '' ) Raised when an invalid cookiecutter repository is provided. View Source class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo: str , details: str = \"\" ): self . cookiecutter_repo = cookiecutter_repo super (). __init__ ( f \"Unable to initialize the cookiecutter using {cookiecutter_repo}! {details.strip()}\" )","title":"InvalidCookiecutterRepository"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_3","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_3","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_3","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_3","text":"def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_3","text":"def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#nocruftfound","text":"class NoCruftFound ( directory : Union [ str , pathlib . Path ] ) Raised when no .cruft.json state is found in the current directory. View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory","title":"NoCruftFound"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_4","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_4","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_4","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_4","text":"def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_4","text":"def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#unabletofindcookiecuttertemplate","text":"class UnableToFindCookiecutterTemplate ( directory : Union [ str , pathlib . Path ] ) Raised when Cruft is unable to find a cookiecutter template. View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory","title":"UnableToFindCookiecutterTemplate"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_5","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_5","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_5","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_5","text":"def format_message ( self ) -> str View Source def format_message ( self ) -> str : return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_5","text":"def show ( self , file : Union [ IO , NoneType ] = None ) -> None View Source def show ( self , file : t . Optional [ t . IO ] = None ) -> None : if file is None : file = get_text_stderr () echo ( _ ( \"Error: {message}\" ). format ( message = self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"}]}